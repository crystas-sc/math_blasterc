<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Math Blasterc</title>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Orientation Prompt for Mobile Portrait */
        #orientation-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        @media screen and (orientation: portrait) and (max-width: 950px) {
            #orientation-overlay {
                display: flex;
            }
        }

        .hud-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            text-shadow: 0 0 10px #0ff;
        }

        #question-display {
            font-size: 2.5rem;
            font-weight: 700;
            color: #0ff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 30px;
            border: 2px solid #0ff;
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .stats-bar {
            display: flex;
            gap: 20px;
            font-size: 1.2rem;
            color: #ff0;
        }

        #lives-display {
            color: #f00;
            font-weight: bold;
            text-shadow: 0 0 5px #f00;
        }

        /* Updated Screen Styles for better height management */
        #start-screen,
        #game-over-screen,
        #settings-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            /* Allow internal scrolling if content overflows */
        }

        h1 {
            font-size: 3rem;
            color: #f0f;
            text-shadow: 0 0 20px #f0f;
            margin: 0 0 10px 0;
            text-align: center;
        }

        .briefing-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            max-width: 500px;
            margin: 10px 0;
        }

        #settings-modal .briefing-box {
            max-height: 50vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #0ff #222;
        }

        #settings-modal .briefing-box::-webkit-scrollbar {
            width: 8px;
        }

        #settings-modal .briefing-box::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #settings-modal .briefing-box::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 4px;
            box-shadow: 0 0 5px #0ff;
        }

        .setting-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            color: #fff;
            padding: 5px;
            font-family: 'Orbitron', sans-serif;
            width: 60px;
            text-align: center;
        }

        p {
            font-size: 1.1rem;
            text-align: center;
            line-height: 1.4;
            margin: 5px 0;
        }

        button {
            margin-top: 15px;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(45deg, #f0f, #0ff);
            border: none;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 0 15px #f0f;
            transition: transform 0.2s, box-shadow 0.2s;
            flex-shrink: 0;
            /* Prevent button from shrinking */
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }


        /* Specific fixes for small landscape screens */
        @media (max-height: 450px) {
            h1 {
                font-size: 1.5rem;
                margin-bottom: 5px;
            }

            #start-screen .briefing-box {
                display: none;
            }

            /* Hide briefing text on tiny screens to prioritize button */
            button {
                margin-top: 5px;
                padding: 10px 30px;
                font-size: 1.1rem;
            }

            #question-display {
                font-size: 1.4rem;
                padding: 5px 15px;
            }

            .stats-bar {
                font-size: 0.9rem;
            }
        }

        @media (max-width: 600px) {
            #question-display {
                font-size: 1.8rem;
                padding: 5px 20px;
            }

            h1 {
                font-size: 2rem;
            }
        }

        .top-right-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 50;
            pointer-events: auto;
        }

        .top-right-controls button {
            margin: 0;
            padding: 8px;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: static;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="orientation-overlay">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#0ff" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <rect x="5" y="2" width="14" height="20" rx="2" ry="2" transform="rotate(90 12 12)"></rect>
            <path d="M12 18h.01"></path>
        </svg>
        <h2 style="color: #0ff; margin: 10px 0;">ROTATE DEVICE</h2>
        <p>Please rotate your device to Landscape mode for the best experience.</p>
    </div>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="question-display">READY?</div>
            <div class="stats-bar">
                <div id="score-el">Score: 0</div>
                <div id="level-el">Level: 1</div>
                <div id="lives-display">Hull: 9</div>
            </div>
        </div>
        <div class="top-right-controls">
            <button id="ingame-settings-btn" class="hidden">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path
                        d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z" />
                </svg>
            </button>
            <button id="pause-btn" class="hidden">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                </svg>
            </button>
        </div>
    </div>

    <div id="start-screen">
        <h1>MATH BLASTERC</h1>
        <div class="briefing-box">
            <p><strong>MISSION BRIEFING:</strong></p>
            <p>üéØ Tap/Click correct asteroid</p>
            <p>‚å®Ô∏è WASD/Arrows to Aim, SPACE to Shoot</p>
            <p>‚ù§Ô∏è You have <strong>9 LIVES</strong>.</p>
        </div>
        <button id="start-btn">START MISSION</button>

    </div>

    <div id="settings-modal" class="hidden">
        <h1>SETTINGS</h1>
        <div class="briefing-box">
            <p><strong>CONFIGURE PARAMETERS</strong></p>

            <div style="margin: 15px 0;">
                <p style="color: #0ff; margin-bottom: 5px;">ADDITION / SUBTRACTION</p>
                <div style="display: flex; gap: 10px; justify-content: center; align-items: center;">
                    <label>Min: <input type="number" id="add-min" value="10" class="setting-input"></label>
                    <label>Max: <input type="number" id="add-max" value="99" class="setting-input"></label>
                </div>
            </div>

            <div style="margin: 15px 0;">
                <p style="color: #0ff; margin-bottom: 5px;">MULTIPLICATION</p>
                <div style="display: flex; gap: 10px; justify-content: center; align-items: center;">
                    <label>Min: <input type="number" id="mul-min" value="2" class="setting-input"></label>
                    <label>Max: <input type="number" id="mul-max" value="9" class="setting-input"></label>
                </div>
            </div>

        </div>
        <div style="display: flex; gap: 20px;">
            <button id="save-settings-btn" style="background: linear-gradient(45deg, #0f0, #0ff);">SAVE</button>
            <button id="close-settings-btn" style="background: linear-gradient(45deg, #f00, #f80);">CANCEL</button>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f00; text-shadow: 0 0 20px #f00;">GAME OVER</h1>
        <p id="final-score">Final Score: 0</p>
        <p id="death-reason">Hull Integrity Failed</p>
        <button id="restart-btn">RETRY</button>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(err => console.log(err));
            });
        }

        const AudioSys = {
            ctx: null,
            init: function () {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playLaser: function () {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },
            playExplosion: function () {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },
            playWrong: function () {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }
        };

        const Input = {
            keys: {
                ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
                w: false, a: false, s: false, d: false,
                " ": false, Enter: false
            },
            cursor: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            cursorSpeed: 15,
            isFiring: false
        };

        const GameState = {
            isPlaying: false,
            score: 0,
            level: 1,
            lives: 9,
            speed: 0.08,
            currentQuestion: null,
            correctAnswer: null,
            asteroids: [],
            lasers: [],
            particles: [],
            waveActive: false,
            isPaused: false,
            pauseInterval: null
        };

        // Math logic
        function createDigitPool(minValue, maxValue) {
            const digits = new Int16Array(maxValue - minValue + 1);
            let remaining = digits.length;

            function resetPool() {
                for (let i = 0; i < digits.length; i++) {
                    digits[i] = minValue + i;
                }
                for (let i = digits.length - 1; i > 0; i--) {
                    const randomIndex = (Math.random() * (i + 1)) | 0;
                    const temp = digits[i];
                    digits[i] = digits[randomIndex];
                    digits[randomIndex] = temp;
                }
                remaining = digits.length;
            }

            resetPool();

            return function getNextDigit() {
                if (remaining === 0) resetPool();
                return digits[--remaining];
            };
        }

        const smallDigits = createDigitPool(1, 9);
        const mediumDigits = createDigitPool(5, 24);
        let largeDigits = createDigitPool(10, 99);
        let multiplyDigits = createDigitPool(2, 9);
        function generateEasyAddition() {
            const left = smallDigits();
            const right = smallDigits();
            return { left, operator: '+', right, answer: left + right };
        }

        function generateMediumAddOrSubtract() {
            if (Math.random() < 0.5) {
                const left = mediumDigits();
                const right = mediumDigits();
                return { left, operator: '+', right, answer: left + right };
            }

            let left = mediumDigits();
            let right = smallDigits();
            if (right > left) {
                const temp = left;
                left = right;
                right = temp;
            }
            return { left, operator: '-', right, answer: left - right };
        }

        function generateMixedAddSubtractMultiply() {
            if (Math.random() < 0.7) {
                const left = multiplyDigits();
                const right = multiplyDigits();
                return { left, operator: '√ó', right, answer: left * right };
            }

            let left = largeDigits();
            let right = mediumDigits();
            const operator = Math.random() < 0.5 ? '+' : '-';

            if (operator === '-' && right > left) {
                const temp = left;
                left = right;
                right = temp;
            }

            return {
                left,
                operator,
                right,
                answer: operator === '+' ? left + right : left - right
            };
        }

        function generateHardMixed() {
            if (Math.random() < 0.7) {
                const left = multiplyDigits();
                const right = multiplyDigits();
                return { left, operator: '√ó', right, answer: left * right };
            }

            let left = largeDigits();
            let right = largeDigits();
            const operator = Math.random() < 0.5 ? '+' : '-';

            if (operator === '-' && right > left) {
                const temp = left;
                left = right;
                right = temp;
            }

            return {
                left,
                operator,
                right,
                answer: operator === '+' ? left + right : left - right
            };
        }



        const settingsModal = document.getElementById('settings-modal');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');

        const ingameSettingsBtn = document.getElementById('ingame-settings-btn');


        function closeSettings() {
            settingsModal.classList.add('hidden');
            if (GameState.isPlaying) {
                // Return to game (paused)
            } else {
                document.getElementById('start-screen').classList.remove('hidden');
            }
        }

        closeSettingsBtn.addEventListener('click', closeSettings);

        saveSettingsBtn.addEventListener('click', () => {
            const addMin = parseInt(document.getElementById('add-min').value) || 10;
            const addMax = parseInt(document.getElementById('add-max').value) || 99;
            const mulMin = parseInt(document.getElementById('mul-min').value) || 2;
            const mulMax = parseInt(document.getElementById('mul-max').value) || 9;

            if (addMin >= addMax || mulMin >= mulMax) {
                alert("Min values must be less than Max values!");
                return;
            }

            largeDigits = createDigitPool(addMin, addMax);
            multiplyDigits = createDigitPool(mulMin, mulMax);

            closeSettings();
        });

        const MathLogic = {
            generate: function (level) {
                const difficulty = Math.min(level, 7);

                let problem;
                if (difficulty <= 1) problem = generateEasyAddition();
                else if (difficulty <= 3) problem = generateMediumAddOrSubtract();
                else if (difficulty <= 5) problem = generateMixedAddSubtractMultiply();
                else problem = generateHardMixed();

                return {
                    q: `${problem.left} ${problem.operator} ${problem.right}`,
                    a: problem.answer
                };
            },
            getWrongAnswers: function (correct, count) {
                const wrongs = new Set();
                while (wrongs.size < count) {
                    let deviation = Math.floor(Math.random() * 10) - 5;
                    if (deviation === 0) deviation = 1;
                    let val = correct + deviation;
                    if (val < 0) val = Math.abs(val) + 1;
                    if (val !== correct) wrongs.add(val);
                }
                return Array.from(wrongs);
            }
        };

        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x404040));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        //begin stars
        function createStarTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, 0,
                size / 2, size / 2, size / 2
            );

            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        const starTexture = createStarTexture();
        const starCount = 2000;
        const radius = 200;

        const positions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
            const u = Math.random();
            const v = Math.random();

            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);

            const r = Math.cbrt(Math.random()) * radius;

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            const index = i * 3;
            positions[index] = x;
            positions[index + 1] = y;
            positions[index + 2] = z;
        }

        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));




        const stars = new THREE.Points(
            starGeo,
            new THREE.PointsMaterial({
                size: 1.2,
                map: starTexture,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            })
        );
        scene.add(stars);



        //end stars

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function createTextTexture(text, color = "#00ffff") {
            const fontSize = 96;
            const padding = 20;

            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            ctx.font = `bold ${fontSize}px Orbitron`;

            // Measure text width
            const metrics = ctx.measureText(text);
            const textWidth = Math.ceil(metrics.width);

            // Resize canvas to fit text
            canvas.width = textWidth + padding * 2;
            canvas.height = fontSize + padding * 2;

            // Redraw after resize
            ctx.font = `bold ${fontSize}px Orbitron`;
            ctx.fillStyle = color;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = color;
            ctx.shadowBlur = 12;

            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.needsUpdate = true;

            return texture;
        }


        function spawnWave() {
            if (GameState.waveActive) return;
            const math = MathLogic.generate(GameState.level);
            GameState.currentQuestion = math.q;
            GameState.correctAnswer = math.a;
            document.getElementById('question-display').innerText = `${math.q} = ?`;
            const count = 3;
            const wrongAnswers = MathLogic.getWrongAnswers(math.a, count - 1);
            const correctIdx = Math.floor(Math.random() * count);
            const spread = 20; const startX = -((count - 1) * spread) / 2;
            for (let i = 0; i < count; i++) {
                const isCorrect = (i === correctIdx);
                const val = isCorrect ? math.a : wrongAnswers.pop();
                const mesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(1.5, 0),
                    new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, flatShading: true })
                );
                mesh.position.set(startX + (i * spread), (Math.random() - 0.5) * 10, -50 - (Math.random() * 10));
                mesh.userData = { rotSpeed: { x: Math.random() * 0.02, y: Math.random() * 0.02 }, isCorrect, value: val, velocity: GameState.speed };
                const spriteMat = new THREE.SpriteMaterial({ map: createTextTexture(val.toString(), '#00ffff'), transparent: true });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.y = 2.2; sprite.scale.set(6, 6, 1);
                mesh.add(sprite);
                scene.add(mesh);
                GameState.asteroids.push(mesh);
            }
            GameState.waveActive = true;
        }

        function createLaser(targetPos) {
            AudioSys.playLaser();
            const points = [new THREE.Vector3(0, -2, 1), targetPos];
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }));
            scene.add(line);
            GameState.lasers.push({ mesh: line, life: 10 });
        }


        function createExplosion(pos, color) {
            for (let i = 0; i < 20; i++) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({ color }));
                mesh.position.copy(pos);
                mesh.userData.vel = new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5);
                scene.add(mesh);
                GameState.particles.push(mesh);
            }
        }

        function checkInput(x, y) {
            if (!GameState.isPlaying || GameState.isPaused) return;
            Input.cursor.x = x; Input.cursor.y = y;
            pointer.x = (x / window.innerWidth) * 2 - 1; pointer.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const target = new THREE.Vector3(); raycaster.ray.at(50, target);
            const intersects = raycaster.intersectObjects(GameState.asteroids);
            if (intersects.length > 0) {
                createLaser(intersects[0].point);
                handleHit(intersects[0].object);
            } else createLaser(target);
        }

        function handleHit(asteroid) {
            scene.remove(asteroid);
            GameState.asteroids = GameState.asteroids.filter(a => a !== asteroid);
            if (asteroid.userData.isCorrect) {
                AudioSys.playExplosion();
                createExplosion(asteroid.position, 0x00ff00);
                GameState.score += 100 * GameState.level;
                GameState.level++;
                //GameState.speed += 0.02;
                GameState.asteroids.forEach(a => { createExplosion(a.position, 0xaaaaaa); scene.remove(a); });
                GameState.asteroids = []; GameState.waveActive = false;
                updateHUD();
            } else {
                AudioSys.playWrong();
                createExplosion(asteroid.position, 0xff0000);
                GameState.score = Math.max(0, GameState.score - 50);
                updateHUD();
            }
        }

        function takeDamage(reason) {
            GameState.lives--;
            AudioSys.playWrong();
            updateHUD();

            GameState.asteroids.forEach(a => { createExplosion(a.position, 0xff0000); scene.remove(a); });
            GameState.asteroids = [];
            GameState.waveActive = false;

            if (GameState.lives <= 0) {
                gameOver(reason);
            }
        }

        function gameOver(reason) {
            GameState.isPlaying = false;
            if (GameState.pauseInterval) clearInterval(GameState.pauseInterval);
            document.getElementById('pause-btn').classList.add('hidden');
            document.getElementById('ingame-settings-btn').classList.add('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = `Final Score: ${GameState.score}`;
            document.getElementById('death-reason').innerText = reason;
        }

        function resetGame() {
            GameState.asteroids.forEach(a => scene.remove(a));
            GameState.particles.forEach(p => scene.remove(p));
            GameState.lasers.forEach(l => scene.remove(l.mesh));
            GameState.asteroids = []; GameState.particles = []; GameState.lasers = [];
            GameState.score = 0; GameState.level = 1; GameState.lives = 9; GameState.speed = 0.08;
            GameState.waveActive = false; GameState.isPlaying = true;
            GameState.isPaused = false;
            if (GameState.pauseInterval) clearInterval(GameState.pauseInterval);
            document.getElementById('pause-btn').classList.remove('hidden');
            document.getElementById('ingame-settings-btn').classList.remove('hidden');
            document.getElementById('pause-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
            Input.cursor.x = window.innerWidth / 2; Input.cursor.y = window.innerHeight / 2;
            updateHUD();
            document.getElementById('ui-layer').classList.remove('hidden');
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            spawnWave();
        }

        function togglePause() {
            if (!GameState.isPlaying) return;
            GameState.isPaused = !GameState.isPaused;
            const btn = document.getElementById('pause-btn');

            if (GameState.isPaused) {
                // Resume Icon
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
                GameState.pauseInterval = setInterval(() => {
                    if (GameState.score > 0) {
                        GameState.score = Math.max(0, GameState.score - 5);
                        updateHUD();
                    }
                }, 200);
            } else {
                // Pause Icon
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
                if (GameState.pauseInterval) clearInterval(GameState.pauseInterval);
            }
        }

        function updateHUD() {
            document.getElementById('score-el').innerText = `Score: ${GameState.score}`;
            document.getElementById('level-el').innerText = `Level: ${GameState.level}`;
            document.getElementById('lives-display').innerText = `Hull: ${GameState.lives}`;
        }

        let slingshot = null;
        let slingBandMesh = null;
        let initialBandMesh = null;
        const bandPoints = [
            new THREE.Vector3(-1, 1.6, 0),
            new THREE.Vector3(0, 1.2, -1),
            new THREE.Vector3(1, 1.6, 0)
        ];

        function createSlingBand(points) {
            const curve = new THREE.CatmullRomCurve3(points);

            const geometry = new THREE.TubeGeometry(
                curve,
                20,     // segments
                0.08,   // thickness (increase for thicker band)
                8,
                false
            );

            const material = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                metalness: 0.3,
                roughness: 0.4
            });

            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function extendSlingBand(increment) {
            slingshot.remove(slingBandMesh);
            const newBandPoints = bandPoints.map(p => p.clone());
            newBandPoints[1].y += increment;
            slingBandMesh = createSlingBand(newBandPoints)
            slingshot.add(slingBandMesh);
        }

        function resetSlingBand() {
            slingshot.remove(slingBandMesh);
            slingBandMesh = initialBandMesh;
            slingshot.add(slingBandMesh);
        }

        function createSlingshot() {
            console.log("createSlingshot");
            const group = new THREE.Group();

            const material = new THREE.MeshStandardMaterial({
                color: 0x4444ff,
                metalness: 0.8,
                roughness: 0.3
            });

            // Left arm
            const leftArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.15, 2.2, 8),
                material
            );
            leftArm.position.set(-0.4, 0.8, 0);
            leftArm.rotation.z = Math.PI / 6;

            // Right arm
            const rightArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.15, 2.2, 8),
                material
            );
            rightArm.position.set(0.4, 0.8, 0);
            rightArm.rotation.z = -Math.PI / 6;

            // Handle
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 2.5, 10),
                material
            );
            handle.position.set(0, -1, 0);

            // Elastic band
            const bandGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-0.4, 1.6, 0),
                new THREE.Vector3(0, 1.2, -1),
                new THREE.Vector3(0.4, 1.6, 0)
            ]);

            const bandMat = new THREE.LineBasicMaterial({
                color: 0xff0000,
                linewidth: 2
            });

            // slingBand = new THREE.Line(bandGeo, bandMat);

            initialBandMesh = slingBandMesh = createSlingBand(bandPoints)

            group.add(leftArm, rightArm, handle, slingBandMesh);
            group.position.set(0, -2.5, 3.5);
            scene.add(group);


            slingshot = group;
        }
        createSlingshot();





        function animate() {
            requestAnimationFrame(animate);
            if (!GameState.isPlaying) return;

            if (GameState.isPaused) {
                renderer.render(scene, camera);
                return;
            }

            let moved = false;
            if (Input.keys.ArrowUp || Input.keys.w) { Input.cursor.y -= Input.cursorSpeed; moved = true; }
            if (Input.keys.ArrowDown || Input.keys.s) { Input.cursor.y += Input.cursorSpeed; moved = true; }
            if (Input.keys.ArrowLeft || Input.keys.a) { Input.cursor.x -= Input.cursorSpeed; moved = true; }
            if (Input.keys.ArrowRight || Input.keys.d) { Input.cursor.x += Input.cursorSpeed; moved = true; }
            if (moved) {
                Input.cursor.x = Math.max(0, Math.min(window.innerWidth, Input.cursor.x));
                Input.cursor.y = Math.max(0, Math.min(window.innerHeight, Input.cursor.y));
            }
            if ((Input.keys[" "] || Input.keys.Enter) && !Input.isFiring) {
                Input.isFiring = true; checkInput(Input.cursor.x, Input.cursor.y);
            } else if (!Input.keys[" "] && !Input.keys.Enter) Input.isFiring = false;

            if (!GameState.waveActive && GameState.asteroids.length === 0) spawnWave();

            for (let i = GameState.asteroids.length - 1; i >= 0; i--) {
                const a = GameState.asteroids[i];
                a.position.z += a.userData.velocity;
                a.rotation.x += a.userData.rotSpeed.x; a.rotation.y += a.userData.rotSpeed.y;
                if (a.position.z > camera.position.z - 1.5) {
                    takeDamage("Hull Impact!");
                    return;
                }
            }

            for (let i = GameState.particles.length - 1; i >= 0; i--) {
                const p = GameState.particles[i];
                p.position.add(p.userData.vel); p.scale.multiplyScalar(0.9);
                if (p.scale.x < 0.01) { scene.remove(p); GameState.particles.splice(i, 1); }
            }

            for (let i = GameState.lasers.length - 1; i >= 0; i--) {
                const l = GameState.lasers[i]; l.life--;
                extendSlingBand((l.life - 10) * 0.00625);
                l.mesh.material.opacity = l.life / 10; l.mesh.material.transparent = true;
                if (l.life <= 0) {
                    scene.remove(l.mesh);
                    GameState.lasers.splice(i, 1);
                    resetSlingBand();
                }
            }
            stars.rotation.z += 0.0005;
            renderer.render(scene, camera);
        }

        window.addEventListener('mousemove', (e) => { if (GameState.isPlaying) { Input.cursor.x = e.clientX; Input.cursor.y = e.clientY; } });
        window.addEventListener('mousedown', (e) => { if (GameState.isPaused) togglePause(); if (e.target.tagName !== 'BUTTON') checkInput(e.clientX, e.clientY); });
        window.addEventListener('touchstart', (e) => { if (e.target.tagName !== 'BUTTON') { const t = e.touches[0]; checkInput(t.clientX, t.clientY); } }, { passive: false });
        window.addEventListener('touchmove', (e) => { if (GameState.isPlaying) { const t = e.touches[0]; Input.cursor.x = t.clientX; Input.cursor.y = t.clientY; } }, { passive: false });
        window.addEventListener('keydown', (e) => { if (Input.keys.hasOwnProperty(e.key)) { Input.keys[e.key] = true; if (e.key === " " && GameState.isPlaying) e.preventDefault(); } });
        window.addEventListener('keyup', (e) => { if (Input.keys.hasOwnProperty(e.key)) Input.keys[e.key] = false; });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            Input.cursor.x = window.innerWidth / 2;
            Input.cursor.y = window.innerHeight / 2;
        });
        document.getElementById('pause-btn').addEventListener('click', () => togglePause());

        document.getElementById('ingame-settings-btn').addEventListener('click', () => {
            if (!GameState.isPlaying) return;
            if (!GameState.isPaused) togglePause();
            settingsModal.classList.remove('hidden');
        });

        const originalCloseSettingsIndex = 0; // Tracks if we came from start screen or game
        // Actually, we can just check GameState.isPlaying when closing.

        // Override the close logic to handle game state
        // We need to move the event listeners or just ensure they work for both contexts.
        // I will re-define them here or update the previous block.
        // It's cleaner to remove the old ones if I'm re-adding, but I can't easily remove anonymous functions.
        // However, I can just update the code in place of user's previous code block if I target it, or add new logic.
        // The previous block for 'closeSettingsBtn' was simple.

        window.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') togglePause();
        });
        document.getElementById('start-btn').addEventListener('click', () => { AudioSys.init(); resetGame(); });
        document.getElementById('restart-btn').addEventListener('click', () => { resetGame(); });
        animate();
    </script>

</body>

</html>