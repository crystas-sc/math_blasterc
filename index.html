<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Math Blaster 3D</title>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Orientation Prompt for Mobile Portrait */
        #orientation-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        @media screen and (orientation: portrait) and (max-width: 950px) {
            #orientation-overlay {
                display: flex;
            }
        }

        .hud-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            text-shadow: 0 0 10px #0ff;
        }

        #question-display {
            font-size: 2.5rem;
            font-weight: 700;
            color: #0ff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 30px;
            border: 2px solid #0ff;
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .stats-bar {
            display: flex;
            gap: 20px;
            font-size: 1.2rem;
            color: #ff0;
        }

        #lives-display {
            color: #f00;
            font-weight: bold;
            text-shadow: 0 0 5px #f00;
        }

        /* Updated Screen Styles for better height management */
        #start-screen,
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            /* Allow internal scrolling if content overflows */
        }

        h1 {
            font-size: 3rem;
            color: #f0f;
            text-shadow: 0 0 20px #f0f;
            margin: 0 0 10px 0;
            text-align: center;
        }

        .briefing-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            max-width: 500px;
            margin: 10px 0;
        }

        p {
            font-size: 1.1rem;
            text-align: center;
            line-height: 1.4;
            margin: 5px 0;
        }

        button {
            margin-top: 15px;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(45deg, #f0f, #0ff);
            border: none;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 0 15px #f0f;
            transition: transform 0.2s, box-shadow 0.2s;
            flex-shrink: 0;
            /* Prevent button from shrinking */
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        #crosshair::before {
            top: 19px;
            left: 0;
            width: 40px;
            height: 2px;
        }

        #crosshair::after {
            top: 0;
            left: 19px;
            width: 2px;
            height: 40px;
        }

        /* Specific fixes for small landscape screens */
        @media (max-height: 450px) {
            h1 {
                font-size: 1.5rem;
                margin-bottom: 5px;
            }

            .briefing-box {
                display: none;
            }

            /* Hide briefing text on tiny screens to prioritize button */
            button {
                margin-top: 5px;
                padding: 10px 30px;
                font-size: 1.1rem;
            }

            #question-display {
                font-size: 1.4rem;
                padding: 5px 15px;
            }

            .stats-bar {
                font-size: 0.9rem;
            }
        }

        @media (max-width: 600px) {
            #question-display {
                font-size: 1.8rem;
                padding: 5px 20px;
            }

            h1 {
                font-size: 2rem;
            }
        }

        #pause-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            margin: 0;
            padding: 10px 20px;
            font-size: 1.2rem;
            width: auto;
            z-index: 50;
            pointer-events: auto;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="orientation-overlay">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#0ff" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <rect x="5" y="2" width="14" height="20" rx="2" ry="2" transform="rotate(90 12 12)"></rect>
            <path d="M12 18h.01"></path>
        </svg>
        <h2 style="color: #0ff; margin: 10px 0;">ROTATE DEVICE</h2>
        <p>Please rotate your device to Landscape mode for the best experience.</p>
    </div>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="question-display">READY?</div>
            <div class="stats-bar">
                <div id="score-el">Score: 0</div>
                <div id="level-el">Level: 1</div>
                <div id="lives-display">Hull: 9</div>
            </div>
        </div>
        <div id="crosshair"></div>
        <button id="pause-btn" class="hidden">PAUSE</button>
    </div>

    <div id="start-screen">
        <h1>MATH BLASTER</h1>
        <div class="briefing-box">
            <p><strong>MISSION BRIEFING:</strong></p>
            <p>üéØ Tap/Click correct asteroid</p>
            <p>‚å®Ô∏è WASD/Arrows to Aim, SPACE to Shoot</p>
            <p>‚ù§Ô∏è You have <strong>9 LIVES</strong>.</p>
        </div>
        <button id="start-btn">START MISSION</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f00; text-shadow: 0 0 20px #f00;">GAME OVER</h1>
        <p id="final-score">Final Score: 0</p>
        <p id="death-reason">Hull Integrity Failed</p>
        <button id="restart-btn">RETRY</button>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(err => console.log(err));
            });
        }

        const AudioSys = {
            ctx: null,
            init: function () {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playLaser: function () {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },
            playExplosion: function () {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },
            playWrong: function () {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }
        };

        const Input = {
            keys: {
                ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
                w: false, a: false, s: false, d: false,
                " ": false, Enter: false
            },
            cursor: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            cursorSpeed: 15,
            isFiring: false
        };

        const GameState = {
            isPlaying: false,
            score: 0,
            level: 1,
            lives: 9,
            speed: 0.08,
            currentQuestion: null,
            correctAnswer: null,
            asteroids: [],
            lasers: [],
            particles: [],
            waveActive: false,
            isPaused: false,
            pauseInterval: null
        };

        // Math logic
        function createDigitPool(minValue, maxValue) {
            const digits = new Int16Array(maxValue - minValue + 1);
            let remaining = digits.length;

            function resetPool() {
                for (let i = 0; i < digits.length; i++) {
                    digits[i] = minValue + i;
                }
                for (let i = digits.length - 1; i > 0; i--) {
                    const randomIndex = (Math.random() * (i + 1)) | 0;
                    const temp = digits[i];
                    digits[i] = digits[randomIndex];
                    digits[randomIndex] = temp;
                }
                remaining = digits.length;
            }

            resetPool();

            return function getNextDigit() {
                if (remaining === 0) resetPool();
                console.log(digits.slice(0, remaining));
                return digits[--remaining];
            };
        }

        const smallDigits = createDigitPool(1, 9);
        const mediumDigits = createDigitPool(5, 24);
        const largeDigits = createDigitPool(10, 99);
        const multiplyDigits = createDigitPool(2, 9);
        function generateEasyAddition() {
            const left = smallDigits();
            const right = smallDigits();
            return { left, operator: '+', right, answer: left + right };
        }

        function generateMediumAddOrSubtract() {
            if (Math.random() < 0.5) {
                const left = mediumDigits();
                const right = mediumDigits();
                return { left, operator: '+', right, answer: left + right };
            }

            let left = mediumDigits();
            let right = smallDigits();
            if (right > left) {
                const temp = left;
                left = right;
                right = temp;
            }
            return { left, operator: '-', right, answer: left - right };
        }

        function generateMixedAddSubtractMultiply() {
            if (Math.random() < 0.7) {
                const left = multiplyDigits();
                const right = multiplyDigits();
                return { left, operator: '√ó', right, answer: left * right };
            }

            let left = largeDigits();
            let right = mediumDigits();
            const operator = Math.random() < 0.5 ? '+' : '-';

            if (operator === '-' && right > left) {
                const temp = left;
                left = right;
                right = temp;
            }

            return {
                left,
                operator,
                right,
                answer: operator === '+' ? left + right : left - right
            };
        }

        function generateHardMixed() {
            if (Math.random() < 0.7) {
                const left = multiplyDigits();
                const right = multiplyDigits();
                return { left, operator: '√ó', right, answer: left * right };
            }

            let left = largeDigits();
            let right = largeDigits();
            const operator = Math.random() < 0.5 ? '+' : '-';

            if (operator === '-' && right > left) {
                const temp = left;
                left = right;
                right = temp;
            }

            return {
                left,
                operator,
                right,
                answer: operator === '+' ? left + right : left - right
            };
        }


        const MathLogic = {
            generate: function (level) {
                const difficulty = Math.min(level, 7);

                let problem;
                if (difficulty <= 1) problem = generateEasyAddition();
                else if (difficulty <= 3) problem = generateMediumAddOrSubtract();
                else if (difficulty <= 5) problem = generateMixedAddSubtractMultiply();
                else problem = generateHardMixed();

                return {
                    q: `${problem.left} ${problem.operator} ${problem.right}`,
                    a: problem.answer
                };
            },
            getWrongAnswers: function (correct, count) {
                const wrongs = new Set();
                while (wrongs.size < count) {
                    let deviation = Math.floor(Math.random() * 10) - 5;
                    if (deviation === 0) deviation = 1;
                    let val = correct + deviation;
                    if (val < 0) val = Math.abs(val) + 1;
                    if (val !== correct) wrongs.add(val);
                }
                return Array.from(wrongs);
            }
        };

        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x404040));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const starGeo = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPos = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i++) starPos[i] = (Math.random() - 0.5) * 400;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 }));
        scene.add(stars);

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function createTextTexture(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = 'bold 100px Orbitron, sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = color; ctx.shadowBlur = 15;
            ctx.fillText(text, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function spawnWave() {
            if (GameState.waveActive) return;
            const math = MathLogic.generate(GameState.level);
            GameState.currentQuestion = math.q;
            GameState.correctAnswer = math.a;
            document.getElementById('question-display').innerText = `${math.q} = ?`;
            const count = 3;
            const wrongAnswers = MathLogic.getWrongAnswers(math.a, count - 1);
            const correctIdx = Math.floor(Math.random() * count);
            const spread = 20; const startX = -((count - 1) * spread) / 2;
            for (let i = 0; i < count; i++) {
                const isCorrect = (i === correctIdx);
                const val = isCorrect ? math.a : wrongAnswers.pop();
                const mesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(1.5, 0),
                    new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, flatShading: true })
                );
                mesh.position.set(startX + (i * spread), (Math.random() - 0.5) * 10, -50 - (Math.random() * 10));
                mesh.userData = { rotSpeed: { x: Math.random() * 0.02, y: Math.random() * 0.02 }, isCorrect, value: val, velocity: GameState.speed };
                const spriteMat = new THREE.SpriteMaterial({ map: createTextTexture(val.toString(), '#00ffff'), transparent: true });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.y = 2.2; sprite.scale.set(6, 6, 1);
                mesh.add(sprite);
                scene.add(mesh);
                GameState.asteroids.push(mesh);
            }
            GameState.waveActive = true;
        }

        function createLaser(targetPos) {
            AudioSys.playLaser();
            const points = [new THREE.Vector3(0.5, -2, 4), targetPos];
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }));
            scene.add(line);
            GameState.lasers.push({ mesh: line, life: 10 });
        }

        function createExplosion(pos, color) {
            for (let i = 0; i < 20; i++) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({ color }));
                mesh.position.copy(pos);
                mesh.userData.vel = new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5);
                scene.add(mesh);
                GameState.particles.push(mesh);
            }
        }

        function checkInput(x, y) {
            if (!GameState.isPlaying || GameState.isPaused) return;
            updateCrosshairPosition(x, y);
            Input.cursor.x = x; Input.cursor.y = y;
            pointer.x = (x / window.innerWidth) * 2 - 1; pointer.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const target = new THREE.Vector3(); raycaster.ray.at(50, target);
            const intersects = raycaster.intersectObjects(GameState.asteroids);
            if (intersects.length > 0) {
                createLaser(intersects[0].point);
                handleHit(intersects[0].object);
            } else createLaser(target);
        }

        function handleHit(asteroid) {
            scene.remove(asteroid);
            GameState.asteroids = GameState.asteroids.filter(a => a !== asteroid);
            if (asteroid.userData.isCorrect) {
                AudioSys.playExplosion();
                createExplosion(asteroid.position, 0x00ff00);
                GameState.score += 100 * GameState.level;
                GameState.level++;
                //GameState.speed += 0.02;
                GameState.asteroids.forEach(a => { createExplosion(a.position, 0xaaaaaa); scene.remove(a); });
                GameState.asteroids = []; GameState.waveActive = false;
                updateHUD();
            } else {
                AudioSys.playWrong();
                createExplosion(asteroid.position, 0xff0000);
                GameState.score = Math.max(0, GameState.score - 50);
                updateHUD();
            }
        }

        function takeDamage(reason) {
            GameState.lives--;
            AudioSys.playWrong();
            updateHUD();

            GameState.asteroids.forEach(a => { createExplosion(a.position, 0xff0000); scene.remove(a); });
            GameState.asteroids = [];
            GameState.waveActive = false;

            if (GameState.lives <= 0) {
                gameOver(reason);
            }
        }

        function gameOver(reason) {
            GameState.isPlaying = false;
            if (GameState.pauseInterval) clearInterval(GameState.pauseInterval);
            document.getElementById('pause-btn').classList.add('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = `Final Score: ${GameState.score}`;
            document.getElementById('death-reason').innerText = reason;
        }

        function resetGame() {
            GameState.asteroids.forEach(a => scene.remove(a));
            GameState.particles.forEach(p => scene.remove(p));
            GameState.lasers.forEach(l => scene.remove(l.mesh));
            GameState.asteroids = []; GameState.particles = []; GameState.lasers = [];
            GameState.score = 0; GameState.level = 1; GameState.lives = 9; GameState.speed = 0.08;
            GameState.waveActive = false; GameState.isPlaying = true;
            GameState.isPaused = false;
            if (GameState.pauseInterval) clearInterval(GameState.pauseInterval);
            document.getElementById('pause-btn').classList.remove('hidden');
            document.getElementById('pause-btn').innerText = 'PAUSE';
            Input.cursor.x = window.innerWidth / 2; Input.cursor.y = window.innerHeight / 2;
            updateCrosshairPosition(Input.cursor.x, Input.cursor.y);
            updateHUD();
            document.getElementById('ui-layer').classList.remove('hidden');
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            spawnWave();
        }

        function togglePause() {
            if (!GameState.isPlaying) return;
            GameState.isPaused = !GameState.isPaused;
            const btn = document.getElementById('pause-btn');

            if (GameState.isPaused) {
                btn.innerText = 'RESUME';
                GameState.pauseInterval = setInterval(() => {
                    if (GameState.score > 0) {
                        GameState.score = Math.max(0, GameState.score - 5);
                        updateHUD();
                    }
                }, 200);
            } else {
                btn.innerText = 'PAUSE';
                if (GameState.pauseInterval) clearInterval(GameState.pauseInterval);
            }
        }

        function updateHUD() {
            document.getElementById('score-el').innerText = `Score: ${GameState.score}`;
            document.getElementById('level-el').innerText = `Level: ${GameState.level}`;
            document.getElementById('lives-display').innerText = `Hull: ${GameState.lives}`;
        }

        function updateCrosshairPosition(x, y) {
            const el = document.getElementById('crosshair');
            el.style.left = x + 'px'; el.style.top = y + 'px';
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!GameState.isPlaying) return;

            if (GameState.isPaused) {
                renderer.render(scene, camera);
                return;
            }

            let moved = false;
            if (Input.keys.ArrowUp || Input.keys.w) { Input.cursor.y -= Input.cursorSpeed; moved = true; }
            if (Input.keys.ArrowDown || Input.keys.s) { Input.cursor.y += Input.cursorSpeed; moved = true; }
            if (Input.keys.ArrowLeft || Input.keys.a) { Input.cursor.x -= Input.cursorSpeed; moved = true; }
            if (Input.keys.ArrowRight || Input.keys.d) { Input.cursor.x += Input.cursorSpeed; moved = true; }
            if (moved) {
                Input.cursor.x = Math.max(0, Math.min(window.innerWidth, Input.cursor.x));
                Input.cursor.y = Math.max(0, Math.min(window.innerHeight, Input.cursor.y));
                updateCrosshairPosition(Input.cursor.x, Input.cursor.y);
            }
            if ((Input.keys[" "] || Input.keys.Enter) && !Input.isFiring) {
                Input.isFiring = true; checkInput(Input.cursor.x, Input.cursor.y);
            } else if (!Input.keys[" "] && !Input.keys.Enter) Input.isFiring = false;

            if (!GameState.waveActive && GameState.asteroids.length === 0) spawnWave();

            for (let i = GameState.asteroids.length - 1; i >= 0; i--) {
                const a = GameState.asteroids[i];
                a.position.z += a.userData.velocity;
                a.rotation.x += a.userData.rotSpeed.x; a.rotation.y += a.userData.rotSpeed.y;
                if (a.position.z > camera.position.z - 1.5) {
                    takeDamage("Hull Impact!");
                    return;
                }
            }

            for (let i = GameState.particles.length - 1; i >= 0; i--) {
                const p = GameState.particles[i];
                p.position.add(p.userData.vel); p.scale.multiplyScalar(0.9);
                if (p.scale.x < 0.01) { scene.remove(p); GameState.particles.splice(i, 1); }
            }

            for (let i = GameState.lasers.length - 1; i >= 0; i--) {
                const l = GameState.lasers[i]; l.life--;
                l.mesh.material.opacity = l.life / 10; l.mesh.material.transparent = true;
                if (l.life <= 0) { scene.remove(l.mesh); GameState.lasers.splice(i, 1); }
            }
            stars.rotation.z += 0.0005;
            renderer.render(scene, camera);
        }

        window.addEventListener('mousemove', (e) => { if (GameState.isPlaying) { Input.cursor.x = e.clientX; Input.cursor.y = e.clientY; updateCrosshairPosition(e.clientX, e.clientY); } });
        window.addEventListener('mousedown', (e) => { if (GameState.isPaused) togglePause(); if (e.target.tagName !== 'BUTTON') checkInput(e.clientX, e.clientY); });
        window.addEventListener('touchstart', (e) => { if (e.target.tagName !== 'BUTTON') { const t = e.touches[0]; checkInput(t.clientX, t.clientY); } }, { passive: false });
        window.addEventListener('touchmove', (e) => { if (GameState.isPlaying) { const t = e.touches[0]; Input.cursor.x = t.clientX; Input.cursor.y = t.clientY; updateCrosshairPosition(t.clientX, t.clientY); } }, { passive: false });
        window.addEventListener('keydown', (e) => { if (Input.keys.hasOwnProperty(e.key)) { Input.keys[e.key] = true; if (e.key === " " && GameState.isPlaying) e.preventDefault(); } });
        window.addEventListener('keyup', (e) => { if (Input.keys.hasOwnProperty(e.key)) Input.keys[e.key] = false; });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            Input.cursor.x = window.innerWidth / 2;
            Input.cursor.y = window.innerHeight / 2;
        });
        document.getElementById('pause-btn').addEventListener('click', () => togglePause());
        window.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') togglePause();
        });
        document.getElementById('start-btn').addEventListener('click', () => { AudioSys.init(); resetGame(); });
        document.getElementById('restart-btn').addEventListener('click', () => { resetGame(); });
        animate();
    </script>
</body>

</html>